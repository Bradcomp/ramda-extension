const input =`
{"isArray":["export const isArray = R.is(Array)"],"isString":["\\nexport const isString = R.is(String)"],"isFunction":["\\nexport const isFunction = R.is(Function)"],"isObject":["\\nexport const isObject = R.is(Object)"],"isPromise":["\\nexport const isPromise = R.allPass([\\n\\tisObject,\\n\\tR.o(isFunction, R.prop('then')),\\n])"],"deepMerge":["\\nexport const deepMerge = R.curry(\\n\\t(a, b) => (isObject(a) && isObject(b) ? R.mergeWith(deepMerge, a, b) : b)\\n)"],"notNil":["\\nexport const notNil = R.o(R.not, R.isNil)"],"notEmpty":["\\nexport const notEmpty = R.o(R.not, R.isEmpty)"],"log":["\\nexport const log = R.tap(x => console.log(x))"],"trace":["\\nexport const trace = R.tap((x, y) => console.log(x, y))"],"notNaN":["\\n\\n// http://stackoverflow.com/questions/9716468/is-there-any-function-like-isnumeric-in-javascript-to-validate-numbers\\nexport const notNaN = R.o(R.not, isNaN)"],"isNumeric":["\\nexport const isNumeric = R.allPass([R.o(notNaN, parseFloat), isFinite])"],"notNumeric":["\\nexport const notNumeric = R.o(R.not, isNumeric)"],"reduceCallable":["\\n\\n// (a → ... → b) → [a, ..., b] → c\\n// Example:\\n// var f = (a) => (b) => a + b\\n// reduceCallable(f, [1, 2]) // 3\\nexport const reduceCallable = R.reduce((acc, next) => acc(next))"],"isNegative":["\\n\\n/**\\n * @sig Number -> Boolean\\n */\\nexport const isNegative = R.gt(0)"],"isEmptyString":["\\n\\n/**\\n * @sig a -> Boolean\\n */\\nexport const isEmptyString = R.equals('')"],"isNilOrEmptyString":["\\n\\n/**\\n * @sig a -> Boolean\\n */\\nexport const isNilOrEmptyString = R.anyPass([R.isNil, isEmptyString])"],"firstTruthy":["\\n\\n/**\\n * Returns first not nil value\\n *\\n * @sig [a] -> a\\n */\\nexport const firstTruthy = R.find(notNil)"],"dispatch":["\\n\\n/**\\n * Returns first not nil value of dispatching list of functions over a input.\\n * @sig [a] -> b\\n */\\nexport const dispatch = R.useWith(R.o(firstTruthy, R.call), [R.juxt, R.identity])"],"alwaysNull":["\\n\\n/**\\n * Returns always null.\\n * @sig a -> null\\n */\\nexport const alwaysNull = R.always(null)"],"noop":["\\n\\n/**\\n * Alias for \`alwaysNull\`\\n * @sig a -> null\\n */\\nexport const noop = alwaysNull"],"startsWith":["\\n\\n/**\\n * Testing string if starts with some prefix.\\n *\\n * @param  {string} prefix\\n * @param  {string} x\\n * @return {boolean}          True if \`x\` starts with \`prefix\`\\n * @sig\\n */\\nexport const startsWith = R.useWith(R.equals, [R.identity, R.take(1)])"],"fromVariadic":["\\n\\n/**\\n * Converts variadic function to function that accepts list.\\n\\n * @sig (a, b, c, ... → d) → ([a, b, c, ...] → d)\\n */\\nexport const fromVariadic = R.unapply(R.identity)"],"containsAll":["\\n\\n/**\\n * Returns \`true\` if all items from first array are in the second array.\\n * @sig [a] -> [a] -> Boolean\\n * @param {Array} List\\n * @param {Array} List\\n * @return {Boolean} If all items from first array are in the second array.\\n * @example\\n *  containsAll(['a', 'b'], ['a', 'b', 'c']) // true\\n *  containsAll(['a', 'b', 'd'], ['a', 'b', 'c']) // false\\n *\\n */\\nexport const containsAll = R.curry(R.compose(R.isEmpty, R.difference))"],"containsAny":["\\n\\n/**\\n * Returns \`true\` if any of the items from first array are in the second array.\\n * @sig [a] -> [a] -> Boolean\\n * @param {Array} List\\n * @param {Array} List\\n * @return {Boolean} If any of the items from first array are in the second array.\\n * @example\\n *  containsAny(['a', 'e'], ['a', 'b', 'c']) // true\\n *  containsAny(['e', 'f'], ['a', 'b', 'c']) // false\\n *\\n */\\nexport const containsAny = R.curry(R.compose(R.not, R.isEmpty, R.intersection))"],"containsNone":["\\n\\n/**\\n * Returns \`true\` if any of the items from first array is not the second array.\\n * @sig [a] -> [a] -> Boolean\\n * @param {Array} List\\n * @param {Array} List\\n * @return {Boolean} If any of the items from first array is not in the second array.\\n * @example\\n *  containsNone(['e', 'f'], ['a', 'b', 'c']) // true\\n *  containsNone(['a', 'f'], ['a', 'b', 'c']) // false\\n *\\n */\\nexport const containsNone = R.curry(R.compose(R.isEmpty, R.intersection))"]}`;

const parsed = JSON.parse(input);


const fs = require('fs');
const R = require('ramda');

const file = R.compose(
	R.map((x) => `export ${x} from './${x}';\n`),
	R.keys
)(parsed)

fs.writeFileSync(`./src/index.js`, `${file};\\n`, 'utf8');
